use ed25519_dalek::{SigningKey, VerifyingKey, Signer, Verifier};
use ssh_key::PrivateKey;
use std::fs;
use std::path::Path;
use zeroize::Zeroizing;

// Production dependencies for Cargo.toml:
// [dependencies]
// ed25519-dalek = "2.0"
// ssh-key = { version = "0.6", features = ["encryption"] }
// zeroize = "1.7"
// rpassword = "7.3"  # For secure password input

#[derive(Debug)]
pub enum KeyError {
    IoError(std::io::Error),
    SshKeyError(ssh_key::Error),
    InvalidKeyType,
    ValidationFailed(String),
}

impl From<std::io::Error> for KeyError {
    fn from(error: std::io::Error) -> Self {
        KeyError::IoError(error)
    }
}

impl From<ssh_key::Error> for KeyError {
    fn from(error: ssh_key::Error) -> Self {
        KeyError::SshKeyError(error)
    }
}

impl std::fmt::Display for KeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            KeyError::IoError(e) => write!(f, "IO error: {}", e),
            KeyError::SshKeyError(e) => write!(f, "SSH key error: {}", e),
            KeyError::InvalidKeyType => write!(f, "Key is not an Ed25519 private key"),
            KeyError::ValidationFailed(msg) => write!(f, "Key validation failed: {}", msg),
        }
    }
}

impl std::error::Error for KeyError {}

pub struct Ed25519KeyManager;

impl Ed25519KeyManager {
    /// Check if a private key file is encrypted (requires passphrase)
    pub fn is_key_encrypted<P: AsRef<Path>>(path: P) -> Result<bool, KeyError> {
        let content = fs::read_to_string(path)?;
        Self::is_openssh_key_encrypted(&content)
    }
    
    /// Check if OpenSSH private key content is encrypted
    fn is_openssh_key_encrypted(content: &str) -> Result<bool, KeyError> {
        // Try to parse without decryption
        match PrivateKey::from_openssh(content) {
            Ok(_) => Ok(false), // Successfully parsed without passphrase = not encrypted
            Err(ssh_key::Error::Encrypted) => Ok(true), // Explicitly encrypted
            Err(e) => Err(KeyError::SshKeyError(e)), // Other parsing error
        }
    }
    
    /// Smart load that detects encryption and prompts for passphrase if needed
    /// Requires the `rpassword` crate for secure password input
    pub fn load_and_validate_smart<P: AsRef<Path>>(path: P) -> Result<SigningKey, KeyError> {
        let path_ref = path.as_ref();
        
        // Check if key is encrypted
        if Self::is_key_encrypted(path_ref)? {
            // Key is encrypted, prompt for passphrase
            println!("Key is encrypted. Please enter passphrase:");
            let passphrase = rpassword::read_password()
                .map_err(|e| KeyError::IoError(std::io::Error::new(
                    std::io::ErrorKind::Other, 
                    format!("Failed to read passphrase: {}", e)
                )))?;
            
            Self::load_and_validate(path_ref, Some(&passphrase))
        } else {
            // Key is not encrypted
            Self::load_and_validate(path_ref, None)
        }
    }
    /// Read an Ed25519 private key with optional passphrase
    pub fn read_private_key<P: AsRef<Path>>(
        path: P, 
        passphrase: Option<&str>
    ) -> Result<SigningKey, KeyError> {
        let content = fs::read_to_string(path)?;
        Self::parse_openssh_private_key(&content, passphrase)
    }
    
    /// Parse OpenSSH private key with optional passphrase
    fn parse_openssh_private_key(
        content: &str, 
        passphrase: Option<&str>
    ) -> Result<SigningKey, KeyError> {
        // Parse the OpenSSH private key
        let private_key = match passphrase {
            Some(pass) => {
                // Use zeroizing string for security
                let pass_z = Zeroizing::new(pass.to_string());
                PrivateKey::from_openssh(content)?
                    .decrypt(&pass_z)?
            },
            None => PrivateKey::from_openssh(content)?,
        };
        
        // Extract Ed25519 key data
        match private_key.key_data() {
            ssh_key::private::KeypairData::Ed25519(keypair) => {
                // Get the private key bytes (32 bytes for Ed25519)
                let private_bytes = keypair.private.as_ref();
                
                if private_bytes.len() != 32 {
                    return Err(KeyError::ValidationFailed(
                        format!("Expected 32 bytes for Ed25519 private key, got {}", private_bytes.len())
                    ));
                }
                
                // Create SigningKey from the private key bytes
                let signing_key = SigningKey::from_bytes(private_bytes)
                    .map_err(|e| KeyError::ValidationFailed(format!("Invalid Ed25519 key: {}", e)))?;
                
                Ok(signing_key)
            },
            _ => Err(KeyError::InvalidKeyType),
        }
    }
    
    /// Validate the private key by testing sign/verify cycle
    pub fn validate_key(signing_key: &SigningKey) -> Result<(), KeyError> {
        let test_message = b"ed25519-key-validation-test";
        
        // Sign the test message
        let signature = signing_key.sign(test_message);
        
        // Get public key and verify
        let verifying_key = signing_key.verifying_key();
        verifying_key
            .verify(test_message, &signature)
            .map_err(|e| KeyError::ValidationFailed(format!("Sign/verify test failed: {}", e)))?;
        
        Ok(())
    }
    
    /// Get the public key in SSH format
    pub fn get_ssh_public_key(signing_key: &SigningKey) -> Result<ssh_key::PublicKey, KeyError> {
        let verifying_key = signing_key.verifying_key();
        let public_bytes = verifying_key.to_bytes();
        
        // Create SSH public key from Ed25519 public key bytes
        let ssh_public_key = ssh_key::PublicKey::new(
            ssh_key::public::KeyData::Ed25519(
                ssh_key::public::Ed25519PublicKey::from_bytes(&public_bytes)
                    .map_err(|e| KeyError::SshKeyError(e))?
            ),
            ""  // No comment
        );
        
        Ok(ssh_public_key)
    }
    
    /// Get the public key as raw bytes
    pub fn get_public_key_bytes(signing_key: &SigningKey) -> [u8; 32] {
        signing_key.verifying_key().to_bytes()
    }
    
    /// Load and validate a key in one operation
    /// Pass None for unencrypted keys, Some(passphrase) for encrypted keys
    pub fn load_and_validate<P: AsRef<Path>>(
        path: P, 
        passphrase: Option<&str>
    ) -> Result<SigningKey, KeyError> {
        let signing_key = Self::read_private_key(path, passphrase)?;
        Self::validate_key(&signing_key)?;
        Ok(signing_key)
    }
}

// Production usage examples
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Method 1: Smart load - automatically detects encryption and prompts
    match Ed25519KeyManager::load_and_validate_smart("~/.ssh/id_ed25519") {
        Ok(signing_key) => {
            println!("✓ Private key loaded and validated successfully");
            
            // Get public key information
            let public_bytes = Ed25519KeyManager::get_public_key_bytes(&signing_key);
            println!("Public key (hex): {}", hex::encode(public_bytes));
        },
        Err(e) => {
            eprintln!("✗ Failed to load key: {}", e);
            return Err(Box::new(e));
        }
    }
    
    // Method 2: Manual detection
    let key_path = "~/.ssh/id_ed25519";
    let signing_key = match Ed25519KeyManager::is_key_encrypted(key_path)? {
        true => {
            println!("Key is encrypted, please enter passphrase:");
            let passphrase = rpassword::read_password()?;
            Ed25519KeyManager::load_and_validate(key_path, Some(&passphrase))?
        },
        false => {
            println!("Key is not encrypted");
            Ed25519KeyManager::load_and_validate(key_path, None)?
        }
    };
    
    // Use the key
    let data = b"Important message to sign";
    let signature = signing_key.sign(data);
    println!("✓ Data signed successfully");
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use ssh_key::PrivateKey;
    use tempfile::NamedTempFile;
    use std::io::Write;
    
    #[test]
    fn test_key_generation_and_validation() {
        // Generate a test Ed25519 key using ssh-key
        let private_key = PrivateKey::random(&mut rand::thread_rng(), ssh_key::Algorithm::Ed25519)
            .expect("Failed to generate key");
        
        // Convert to OpenSSH format
        let openssh_content = private_key.to_openssh(ssh_key::LineEnding::LF)
            .expect("Failed to convert to OpenSSH format");
        
        // Write to temporary file
        let mut temp_file = NamedTempFile::new().expect("Failed to create temp file");
        temp_file.write_all(openssh_content.as_bytes()).expect("Failed to write key");
        
        // Test loading and validation
        let signing_key = Ed25519KeyManager::load_and_validate(temp_file.path(), None)
            .expect("Failed to load test key");
        
        // Test signing
        let message = b"test message";
        let signature = signing_key.sign(message);
        
        // Test verification
        let verifying_key = signing_key.verifying_key();
        verifying_key.verify(message, &signature).expect("Signature verification failed");
    }
    
    #[test]
    fn test_encryption_detection() {
        // Test with unencrypted key
        let private_key = PrivateKey::random(&mut rand::thread_rng(), ssh_key::Algorithm::Ed25519)
            .expect("Failed to generate key");
        
        let openssh_content = private_key.to_openssh(ssh_key::LineEnding::LF)
            .expect("Failed to convert to OpenSSH format");
        
        let mut temp_file = NamedTempFile::new().expect("Failed to create temp file");
        temp_file.write_all(openssh_content.as_bytes()).expect("Failed to write key");
        
        // Should detect as not encrypted
        let is_encrypted = Ed25519KeyManager::is_key_encrypted(temp_file.path())
            .expect("Failed to check encryption status");
        assert!(!is_encrypted, "Unencrypted key should not be detected as encrypted");
        
        // Should load successfully without passphrase
        let _signing_key = Ed25519KeyManager::load_and_validate(temp_file.path(), None)
            .expect("Failed to load unencrypted key");
    }
}