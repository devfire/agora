# Cargo.toml
[package]
name = "multicast-chat"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["net", "rt-multi-thread", "macros", "io-util"] }
prost = "0.12"
ed25519-dalek = "2.0"
x25519-dalek = "2.0"
chacha20poly1305 = "0.10"
rand = "0.8"
hex = "0.4"
anyhow = "1.0"
ssh-key = "0.6"
base64 = "0.22"

[build-dependencies]
prost-build = "0.12"

# build.rs
fn main() {
    prost_build::compile_protos(&["src/chat.proto"], &["src/"]).unwrap();
}

# src/chat.proto
syntax = "proto3";

message ChatPacket {
  oneof packet_type {
    PublicKeyAnnouncement public_key = 1;
    KeyDistribution key_dist = 2;
    EncryptedMessage encrypted_msg = 3;
  }
}

message PublicKeyAnnouncement {
  string user_id = 1;
  bytes x25519_public_key = 2;  // 32 bytes for ECDH
  bytes ed25519_public_key = 3; // 32 bytes for verification
}

message KeyDistribution {
  string sender_id = 1;
  uint32 key_id = 2;
  bytes encrypted_sender_key = 3;
  string recipient_id = 4;
}

message EncryptedMessage {
  string sender_id = 1;
  uint32 key_id = 2;
  bytes encrypted_payload = 3;
  bytes nonce = 4;
}

message PlaintextPayload {
  string sender_id = 1;
  string content = 2;
  uint64 timestamp = 3;
}

# src/crypto.rs
use ed25519_dalek::{SigningKey, VerifyingKey};
use x25519_dalek::{StaticSecret, PublicKey as X25519PublicKey};
use chacha20poly1305::{ChaCha20Poly1305, Key, Nonce, KeyInit, AeadCore, aead::Aead};
use rand::rngs::OsRng;
use std::collections::HashMap;
use std::path::Path;
use anyhow::{Result, anyhow};
use ssh_key::{PrivateKey, Algorithm};

pub struct HybridChatCrypto {
    // Our Ed25519 identity (for signatures/verification)
    our_signing_key: SigningKey,
    our_verifying_key: VerifyingKey,
    
    // Our X25519 key derived from Ed25519 (for ECDH)
    our_x25519_secret: StaticSecret,
    our_x25519_public: X25519PublicKey,
    our_user_id: String,
    
    // Peer public keys for key distribution
    peer_x25519_keys: HashMap<String, X25519PublicKey>,
    peer_verifying_keys: HashMap<String, VerifyingKey>,
    
    // Symmetric sender keys (what actually encrypts messages)
    our_sender_keys: HashMap<u32, (ChaCha20Poly1305, [u8; 32])>, // cipher + raw key bytes
    current_key_id: u32,
    peer_sender_keys: HashMap<String, HashMap<u32, ChaCha20Poly1305>>,
}

impl HybridChatCrypto {
    pub fn new(user_id: String) -> Self {
        // Generate new keys (fallback if SSH key loading fails)
        let our_signing_key = SigningKey::generate(&mut OsRng);
        let our_verifying_key = our_signing_key.verifying_key();
        
        // Convert Ed25519 to X25519 for ECDH
        let our_x25519_secret = StaticSecret::random_from_rng(OsRng);
        let our_x25519_public = X25519PublicKey::from(&our_x25519_secret);
        
        let mut crypto = Self {
            our_signing_key,
            our_verifying_key,
            our_x25519_secret,
            our_x25519_public,
            our_user_id: user_id,
            peer_x25519_keys: HashMap::new(),
            peer_verifying_keys: HashMap::new(),
            our_sender_keys: HashMap::new(),
            current_key_id: 0,
            peer_sender_keys: HashMap::new(),
        };
        
        crypto.generate_new_sender_key();
        crypto
    }
    
    pub fn from_ssh_key(user_id: String, ssh_key_path: &Path) -> Result<Self> {
        // Read SSH private key
        let key_data = std::fs::read_to_string(ssh_key_path)?;
        let private_key = PrivateKey::from_openssh(&key_data)?;
        
        let our_signing_key = match private_key.algorithm() {
            Algorithm::Ed25519 => {
                let key_data = private_key.key_data();
                if let ssh_key::private::KeypairData::Ed25519(ed25519_keypair) = key_data {
                    SigningKey::from_bytes(&ed25519_keypair.private.to_bytes())
                } else {
                    return Err(anyhow!("Failed to extract Ed25519 key data"));
                }
            }
            _ => return Err(anyhow!("Only Ed25519 SSH keys are supported")),
        };
        
        let our_verifying_key = our_signing_key.verifying_key();
        
        // Convert Ed25519 secret key to X25519 for ECDH
        // This is a standard conversion using the same key material
        let ed25519_secret_bytes = our_signing_key.to_bytes();
        let our_x25519_secret = StaticSecret::from(ed25519_secret_bytes);
        let our_x25519_public = X25519PublicKey::from(&our_x25519_secret);
        
        let mut crypto = Self {
            our_signing_key,
            our_verifying_key,
            our_x25519_secret,
            our_x25519_public,
            our_user_id: user_id,
            peer_x25519_keys: HashMap::new(),
            peer_verifying_keys: HashMap::new(),
            our_sender_keys: HashMap::new(),
            current_key_id: 0,
            peer_sender_keys: HashMap::new(),
        };
        
        crypto.generate_new_sender_key();
        Ok(crypto)
    }
    
    pub fn our_x25519_public_key(&self) -> &X25519PublicKey {
        &self.our_x25519_public
    }
    
    pub fn our_verifying_key(&self) -> &VerifyingKey {
        &self.our_verifying_key
    }
    
    pub fn our_user_id(&self) -> &str {
        &self.our_user_id
    }
    
    pub fn add_peer_keys(&mut self, user_id: String, x25519_public_bytes: &[u8], ed25519_public_bytes: &[u8]) -> Result<()> {
        if x25519_public_bytes.len() != 32 {
            return Err(anyhow!("Invalid X25519 public key length"));
        }
        if ed25519_public_bytes.len() != 32 {
            return Err(anyhow!("Invalid Ed25519 public key length"));
        }
        
        let mut x25519_array = [0u8; 32];
        x25519_array.copy_from_slice(x25519_public_bytes);
        let x25519_public = X25519PublicKey::from(x25519_array);
        
        let mut ed25519_array = [0u8; 32];
        ed25519_array.copy_from_slice(ed25519_public_bytes);
        let verifying_key = VerifyingKey::from_bytes(&ed25519_array)?;
        
        self.peer_x25519_keys.insert(user_id.clone(), x25519_public);
        self.peer_verifying_keys.insert(user_id, verifying_key);
        Ok(())
    }
    
    pub fn generate_new_sender_key(&mut self) -> u32 {
        let mut key_bytes = [0u8; 32];
        rand::thread_rng().fill_bytes(&mut key_bytes);
        
        let key = Key::from_slice(&key_bytes);
        let cipher = ChaCha20Poly1305::new(key);
        
        self.current_key_id += 1;
        self.our_sender_keys.insert(self.current_key_id, (cipher, key_bytes));
        self.current_key_id
    }
    
    pub fn current_key_id(&self) -> u32 {
        self.current_key_id
    }
    
    // Create encrypted sender key for a specific recipient
    pub fn create_key_distribution(&self, recipient_id: &str) -> Result<Vec<u8>> {
        let recipient_x25519_public = self.peer_x25519_keys.get(recipient_id)
            .ok_or_else(|| anyhow!("Unknown recipient: {}", recipient_id))?;
        
        // Perform ECDH to get shared secret
        let shared_secret = self.our_x25519_secret.diffie_hellman(recipient_x25519_public);
        
        // Use shared secret as encryption key
        let key = Key::from_slice(shared_secret.as_bytes());
        let cipher = ChaCha20Poly1305::new(key);
        
        let (_, sender_key_bytes) = self.our_sender_keys.get(&self.current_key_id)
            .ok_or_else(|| anyhow!("No current sender key"))?;
        
        let nonce = ChaCha20Poly1305::generate_nonce(&mut OsRng);
        let encrypted_key = cipher.encrypt(&nonce, sender_key_bytes.as_ref())?;
        
        // Prepend nonce to encrypted key
        let mut result = nonce.to_vec();
        result.extend_from_slice(&encrypted_key);
        Ok(result)
    }
    
    // Decrypt and store a peer's sender key
    pub fn process_key_distribution(&mut self, sender_id: &str, key_id: u32, encrypted_data: &[u8]) -> Result<()> {
        let sender_x25519_public = self.peer_x25519_keys.get(sender_id)
            .ok_or_else(|| anyhow!("Unknown sender: {}", sender_id))?;
        
        if encrypted_data.len() < 12 {
            return Err(anyhow!("Encrypted data too short"));
        }
        
        // Extract nonce and encrypted key
        let (nonce_bytes, encrypted_key) = encrypted_data.split_at(12);
        let nonce = Nonce::from_slice(nonce_bytes);
        
        // Perform ECDH to get shared secret
        let shared_secret = self.our_x25519_secret.diffie_hellman(sender_x25519_public);
        
        // Use shared secret as decryption key
        let key = Key::from_slice(shared_secret.as_bytes());
        let cipher = ChaCha20Poly1305::new(key);
        
        let decrypted_key = cipher.decrypt(nonce, encrypted_key)?;
        
        if decrypted_key.len() != 32 {
            return Err(anyhow!("Invalid sender key length"));
        }
        
        let sender_key = Key::from_slice(&decrypted_key);
        let sender_cipher = ChaCha20Poly1305::new(sender_key);
        
        self.peer_sender_keys
            .entry(sender_id.to_string())
            .or_insert_with(HashMap::new)
            .insert(key_id, sender_cipher);
        
        debug!("Added sender key for {} (key_id: {})", sender_id, key_id);
        Ok(())
    }
    
    pub fn encrypt_message(&self, content: &str) -> Result<(Vec<u8>, Vec<u8>)> {
        use prost::Message;
        use crate::chat::PlaintextPayload;
        
        let payload = PlaintextPayload {
            sender_id: self.our_user_id.clone(),
            content: content.to_string(),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)?
                .as_secs(),
        };
        
        let payload_bytes = payload.encode_to_vec();
        let (cipher, _) = self.our_sender_keys.get(&self.current_key_id)
            .ok_or_else(|| anyhow!("No current sender key"))?;
        
        let nonce = ChaCha20Poly1305::generate_nonce(&mut OsRng);
        let encrypted_payload = cipher.encrypt(&nonce, payload_bytes.as_ref())?;
        
        Ok((encrypted_payload, nonce.to_vec()))
    }
    
    pub fn decrypt_message(&self, sender_id: &str, key_id: u32, encrypted_payload: &[u8], nonce_bytes: &[u8]) -> Result<String> {
        use prost::Message;
        use crate::chat::PlaintextPayload;
        
        let sender_keys = self.peer_sender_keys.get(sender_id)
            .ok_or_else(|| anyhow!("Unknown sender: {}", sender_id))?;
        
        let cipher = sender_keys.get(&key_id)
            .ok_or_else(|| anyhow!("Unknown key ID {} for sender {}", key_id, sender_id))?;
        
        if nonce_bytes.len() != 12 {
            return Err(anyhow!("Invalid nonce length"));
        }
        
        let nonce = Nonce::from_slice(nonce_bytes);
        let decrypted_bytes = cipher.decrypt(nonce, encrypted_payload)?;
        
        let payload = PlaintextPayload::decode(decrypted_bytes.as_slice())?;
        Ok(payload.content)
    }
    
    pub fn list_known_peers(&self) -> Vec<&String> {
        self.peer_x25519_keys.keys().collect()
    }
    
    // Helper function to get SSH key path
    pub fn get_ssh_key_path() -> Result<std::path::PathBuf> {
        let home = std::env::var("HOME")
            .map_err(|_| anyhow!("HOME environment variable not set"))?;
        Ok(std::path::Path::new(&home).join(".ssh").join("id_ed25519"))
    }
}

# src/main.rs
mod crypto;

use crypto::HybridChatCrypto;
use tokio::net::UdpSocket;
use std::net::{Ipv4Addr, SocketAddr};
use prost::Message;
use anyhow::Result;

// Include generated protobuf code
pub mod chat {
    include!(concat!(env!("OUT_DIR"), "/_.rs"));
}

use chat::*;

pub struct MulticastChat {
    socket: UdpSocket,
    multicast_addr: SocketAddr,
    crypto: HybridChatCrypto,
}

impl MulticastChat {
    pub async fn new(user_id: String) -> Result<Self> {
        let socket = UdpSocket::bind("0.0.0.0:0").await?;
        let multicast_addr: SocketAddr = "239.1.1.1:8080".parse()?;
        
        // Join multicast group
        socket.join_multicast_v4(
            Ipv4Addr::new(239, 1, 1, 1),
            Ipv4Addr::UNSPECIFIED,
        )?;
        
        // Try to load SSH key, fallback to generated key
        let crypto = match HybridChatCrypto::get_ssh_key_path() {
            Ok(ssh_path) if ssh_path.exists() => {
                match HybridChatCrypto::from_ssh_key(user_id.clone(), &ssh_path) {
                    Ok(crypto) => {
                        debug!("Loaded SSH key from {}", ssh_path.display());
                        crypto
                    }
                    Err(e) => {
                        println!("Failed to load SSH key ({}), generating new key", e);
                        HybridChatCrypto::new(user_id)
                    }
                }
            }
            _ => {
                println!("SSH key not found, generating new key");
                HybridChatCrypto::new(user_id)
            }
        };
        
        Ok(Self {
            socket,
            multicast_addr,
            crypto,
        })
    }
    
    // Announce our public key to the group
    pub async fn announce_public_key(&self) -> Result<()> {
        let announcement = PublicKeyAnnouncement {
            user_id: self.crypto.our_user_id().to_string(),
            x25519_public_key: self.crypto.our_x25519_public_key().as_bytes().to_vec(),
            ed25519_public_key: self.crypto.our_verifying_key().as_bytes().to_vec(),
        };
        
        let packet = ChatPacket {
            packet_type: Some(chat_packet::PacketType::PublicKey(announcement)),
        };
        
        let packet_bytes = packet.encode_to_vec();
        self.socket.send_to(&packet_bytes, self.multicast_addr).await?;
        
        println!("Announced public keys");
        Ok(())
    }
    
    // Distribute our current sender key to all known peers
    pub async fn distribute_sender_key(&self) -> Result<()> {
        for peer_id in self.crypto.list_known_peers() {
            match self.crypto.create_key_distribution(peer_id) {
                Ok(encrypted_key) => {
                    let key_dist = KeyDistribution {
                        sender_id: self.crypto.our_user_id().to_string(),
                        key_id: self.crypto.current_key_id(),
                        encrypted_sender_key: encrypted_key,
                        recipient_id: peer_id.clone(),
                    };
                    
                    let packet = ChatPacket {
                        packet_type: Some(chat_packet::PacketType::KeyDist(key_dist)),
                    };
                    
                    let packet_bytes = packet.encode_to_vec();
                    self.socket.send_to(&packet_bytes, self.multicast_addr).await?;
                }
                Err(e) => {
                    eprintln!("Failed to create key distribution for {}: {}", peer_id, e);
                }
            }
        }
        
        if !self.crypto.list_known_peers().is_empty() {
            println!("Distributed sender key to {} peers", self.crypto.list_known_peers().len());
        }
        Ok(())
    }
    
    pub async fn send_message(&self, content: &str) -> Result<()> {
        let (encrypted_payload, nonce) = self.crypto.encrypt_message(content)?;
        
        let encrypted_msg = EncryptedMessage {
            sender_id: self.crypto.our_user_id().to_string(),
            key_id: self.crypto.current_key_id(),
            encrypted_payload,
            nonce,
        };
        
        let packet = ChatPacket {
            packet_type: Some(chat_packet::PacketType::EncryptedMsg(encrypted_msg)),
        };
        
        let packet_bytes = packet.encode_to_vec();
        self.socket.send_to(&packet_bytes, self.multicast_addr).await?;
        
        println!("You: {}", content);
        Ok(())
    }
    
    pub async fn receive_and_process(&mut self) -> Result<()> {
        let mut buf = [0u8; 4096];
        let (len, _) = self.socket.recv_from(&mut buf).await?;
        
        let packet = ChatPacket::decode(&buf[..len])?;
        
        match packet.packet_type {
            Some(chat_packet::PacketType::PublicKey(announcement)) => {
                if announcement.user_id != self.crypto.our_user_id() {
                    self.crypto.add_peer_keys(
                        announcement.user_id.clone(),
                        &announcement.x25519_public_key,
                        &announcement.ed25519_public_key
                    )?;
                    println!("New peer joined: {}", announcement.user_id);
                    
                    // Distribute our sender key to the new peer
                    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                    self.distribute_sender_key().await?;
                }
            }
            
            Some(chat_packet::PacketType::KeyDist(key_dist)) => {
                if key_dist.recipient_id == self.crypto.our_user_id() {
                    self.crypto.process_key_distribution(
                        &key_dist.sender_id,
                        key_dist.key_id,
                        &key_dist.encrypted_sender_key
                    )?;
                }
            }
            
            Some(chat_packet::PacketType::EncryptedMsg(encrypted_msg)) => {
                if encrypted_msg.sender_id != self.crypto.our_user_id() {
                    match self.crypto.decrypt_message(
                        &encrypted_msg.sender_id,
                        encrypted_msg.key_id,
                        &encrypted_msg.encrypted_payload,
                        &encrypted_msg.nonce
                    ) {
                        Ok(content) => {
                            println!("{}: {}", encrypted_msg.sender_id, content);
                        }
                        Err(_) => {
                            println!("(encrypted message from {} - no key)", encrypted_msg.sender_id);
                        }
                    }
                }
            }
            
            None => {}
        }
        
        Ok(())
    }
    
    pub fn user_id(&self) -> &str {
        self.crypto.our_user_id()
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} <username>", args[0]);
        std::process::exit(1);
    }
    
    let username = &args[1];
    let mut chat = MulticastChat::new(username.clone()).await?;
    
    println!("Starting chat as '{}'. Type messages and press Enter.", username);
    println!("Using SSH key: {}", HybridChatCrypto::get_ssh_key_path()?.display());
    println!("Commands: /announce - announce public key, /distribute - share sender key");
    
    // Announce our presence
    chat.announce_public_key().await?;
    
    // Spawn receiver task
    let mut receiver_chat = MulticastChat::new(username.clone()).await?;
    
    tokio::spawn(async move {
        loop {
            if let Err(e) = receiver_chat.receive_and_process().await {
                eprintln!("Receive error: {}", e);
            }
        }
    });
    
    // Main input loop
    let stdin = tokio::io::stdin();
    loop {
        let mut input = String::new();
        stdin.read_line(&mut input).await?;
        let input = input.trim();
        
        if input.is_empty() {
            continue;
        }
        
        match input {
            "/announce" => {
                chat.announce_public_key().await?;
            }
            "/distribute" => {
                chat.distribute_sender_key().await?;
            }
            "/peers" => {
                let peers = chat.crypto.list_known_peers();
                println!("Known peers: {:?}", peers);
            }
            _ => {
                if let Err(e) = chat.send_message(input).await {
                    eprintln!("Send error: {}", e);
                }
            }
        }
    }
}